/*!
 * canvas-circular-countdown
 * Draw a configurable circular canvas countdown timer
 *
 * @version v1.8.0
 * @author George Raptis <georapbox@gmail.com>
 * @homepage https://github.com/georapbox/canvas-circular-countdown#readme
 * @repository git+https://github.com/georapbox/canvas-circular-countdown.git
 * @license MIT
 */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).CanvasCircularCountdown = e() }(this, (function () { "use strict"; function t(t, e) { var i = Object.keys(t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(t); e && (o = o.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), i.push.apply(i, o) } return i } function e(e) { for (var o = 1; o < arguments.length; o++) { var r = null != arguments[o] ? arguments[o] : {}; o % 2 ? t(Object(r), !0).forEach((function (t) { i(e, t, r[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : t(Object(r)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t)) })) } return e } function i(t, e, i) { return e in t ? Object.defineProperty(t, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = i, t } function o() { return window.performance ? window.performance.now() : Date.now ? Date.now() : (new Date).getTime() } function r(t) { !1 !== t._started && (t._time = t._time + o() - t._now, t.stop().start(), "function" == typeof t._callback && t._callback(t)) } class n { constructor(t, e, i) { this._started = !1, this._now = 0, this._time = e, this._duration = t, this._defaultElapsedTime = e, this._callback = i } time() { return { remaining: Math.max(0, this._duration - this._time), elapsed: this._time } } start(t) { return t && this.reset(!0), this._started || Number(this._duration) && this._time > this._duration || (this._started = !0, this._now = o(), window.requestAnimationFrame(r.bind(this, this))), this } stop() { return this._started = !1, this } reset(t) { return t && this.stop(), this._time = this._defaultElapsedTime, this } isRunning() { return this._started } setDuration(t) { return this._duration = t, this } setElapsedTime(t) { return this._time = t, this } } function s(t, e) { const { options: i } = e, o = 1.5 * Math.PI, r = o + (i.clockwise ? -1 : 1) * (t / 50 * Math.PI), n = Math.ceil(t); let s = i.radius < 0 ? 0 : i.radius, a = i.radius - i.progressBarOffset - i.progressBarWidth / 2; a = a < 0 ? 0 : a; const c = s, h = s; if (e._ctx.save(), e._ctx.clearRect(0, 0, e._canvas.width, e._canvas.height), e._ctx.beginPath(), e._ctx.arc(c, h, s, 0, 2 * Math.PI, !1), e._ctx.fillStyle = i.circleBackgroundColor, e._ctx.fill(), i.progressBarWidth && (e._ctx.beginPath(), e._ctx.arc(c, h, a, o, 4 * Math.PI, !1), e._ctx.lineWidth = i.progressBarWidth, e._ctx.strokeStyle = i.emptyProgressBarBackgroundColor, e._ctx.stroke()), i.progressBarWidth && (e._ctx.beginPath(), e._ctx.arc(c, h, a, o, r, !!i.clockwise), e._ctx.lineWidth = i.progressBarWidth, e._ctx.strokeStyle = "function" == typeof i.filledProgressBarBackgroundColor ? i.filledProgressBarBackgroundColor(n, e._timer.time()) : i.filledProgressBarBackgroundColor, e._ctx.stroke()), "function" == typeof i.showCaption ? i.showCaption(n, e._timer.time()) : !!i.showCaption) { e._ctx.fillStyle = "function" == typeof i.captionColor ? i.captionColor(n, e._timer.time()) : i.captionColor, e._ctx.font = "function" == typeof i.captionFont ? i.captionFont(n, e._timer.time()) : i.captionFont, e._ctx.textBaseline = "middle", e._ctx.textAlign = "center"; let t = "".concat(n, "%"); if ("string" == typeof i.captionText ? t = i.captionText : "function" == typeof i.captionText && (t = i.captionText(n, e._timer.time())), e._ctx.fillText(t, c, h), e._ctx.restore(), "function" == typeof i.draw) { const t = 2 * i.radius; e._ctx.beginPath(), i.draw(e._ctx, { percentage: n, time: e._timer.time(), width: t, height: t }) } } } function a(t) { const e = t.getContext("2d"), i = window.devicePixelRatio || 1, o = e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1, r = i / o; if (i !== o) { const i = t.width, o = t.height; t.width = Math.round(i * r), t.height = Math.round(o * r), t.style.width = i + "px", t.style.height = o + "px", e.scale(r, r) } return e } function c(t, e, i) { if ("number" != typeof t || "number" != typeof e || "number" != typeof i) throw new TypeError('"normalise" expects numbers as arguments'); return (t - e) / (i - e) } return class { constructor(t, i, o) { if ("function" == typeof i && (o = i, i = {}), this.options = e(e({}, { duration: 6e4, elapsedTime: 0, throttle: void 0, clockwise: !1, radius: 150, progressBarWidth: 15, progressBarOffset: 5, circleBackgroundColor: "#ffffff", emptyProgressBarBackgroundColor: "#dddddd", filledProgressBarBackgroundColor: "#00bfeb", showCaption: !0, captionColor: "#343a40", captionFont: "20px sans-serif" }), i), this.setDuration(this.options.duration), this.setElapsedTime(this.options.elapsedTime), "CANVAS" === t.nodeName) this._canvas = t; else { const e = document.createElement("canvas"); t.appendChild(e), this._canvas = e } const r = t => { const e = 100 * c(t.time().remaining, 0, this.options.duration) || 0; s(e, this), "function" == typeof o && o(Math.ceil(e), t.time(), this) }, h = "number" == typeof this.options.throttle && !Number.isNaN(this.options.throttle) && this.options.throttle <= this.options.duration; this._timer = new n(this.options.duration, this.options.elapsedTime, h ? function (t, e) { let i, o; if ("function" != typeof t) throw new TypeError("Expected a function for first argument"); return function () { for (var r = arguments.length, n = new Array(r), s = 0; s < r; s++)n[s] = arguments[s]; o ? (clearTimeout(i), i = setTimeout((function () { Date.now() - o >= e && (t.apply(void 0, n), o = Date.now()) }), e - (Date.now() - o) || 0)) : (t.apply(void 0, n), o = Date.now()) } }(r, this.options.throttle) : r), this._canvas.width = 2 * this.options.radius, this._canvas.height = 2 * this.options.radius, this._ctx = a(this._canvas); s(100 * c(this._timer.time().remaining, 0, this.options.duration) || 0, this) } setDuration(t) { if ("number" != typeof t || Number.isNaN(t)) throw new TypeError('Expected a number for "duration"'); t < 0 && (t = 0), this.options.duration = t, this._timer && this._timer.setDuration(t) } setElapsedTime(t) { if ("number" != typeof t || Number.isNaN(t)) throw new TypeError('Expected a number for "elapsedTime"'); t > this.options.duration && (t = this.options.duration), t < 0 && (t = 0), this.options.elapsedTime = t, this._timer && this._timer.setElapsedTime(t) } style() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const i = e({}, this.options); this.options = e(e(e({}, i), t), {}, { duration: this.options.duration, elapsedTime: this.options.elapsedTime, throttle: this.options.throttle }); const o = 100 * c(this._timer.time().remaining, 0, this.options.duration) || 0; return this._canvas.width = 2 * this.options.radius, this._canvas.height = 2 * this.options.radius, this._ctx = a(this._canvas), s(o, this), this } start() { return 0 === this.options.duration || this._timer.start(!1), this } stop() { return this._timer.stop(), this } reset() { this._timer.reset(!0); return s(100 * c(this._timer.time().remaining, 0, this.options.duration) || 0, this), this } } }));